--- a/technical-edition/chapter-06-immune-system-security.md
+++ b/technical-edition/chapter-06-immune-system-security.md
@@
 ## Container Security
@@
+## Password and Credential Hygiene
+
+### Argon2id for Password Hashing
+
+Argon2id is the recommended password hashing algorithm for modern systems. It is memory‑hard and resistant to GPU/ASIC attacks. When storing user credentials:
+
+* Use Argon2id with strong parameters (for example, 32–64 MiB memory cost, 2–4 iterations, and parallelism matching the number of CPU cores). Adjust parameters based on your hardware.
+* Generate a **unique salt per user** and store it alongside the hash.
+* Store a **global pepper** in a secrets manager such as Vault and combine it with the password before hashing. The pepper must never be stored in the database.
+* When your parameter recommendations change, **rehash passwords** on login to upgrade them.
+
+Below is an example of hashing and verifying passwords with Argon2id in Go using `golang.org/x/crypto/argon2`:
+
+```go
+// password.go
+package password
+
+import (
+    "crypto/rand"
+    "crypto/subtle"
+    "encoding/base64"
+    "fmt"
+    "strings"
+
+    "golang.org/x/crypto/argon2"
+)
+
+// HashPassword hashes a password with a random salt and returns the encoded hash.
+func HashPassword(password, pepper string) (string, error) {
+    salt := make([]byte, 16)
+    if _, err := rand.Read(salt); err != nil {
+        return "", err
+    }
+    // Combine password with pepper
+    pwd := append([]byte(password+pepper), salt...)
+    hash := argon2.IDKey(pwd, salt, 3, 64*1024, 2, 32)
+    // Encode as base64: salt$hash
+    encoded := fmt.Sprintf("%s$%s",
+        base64.RawStdEncoding.EncodeToString(salt),
+        base64.RawStdEncoding.EncodeToString(hash))
+    return encoded, nil
+}
+
+// VerifyPassword compares a plaintext password against an encoded hash.
+func VerifyPassword(password, pepper, encoded string) bool {
+    parts := strings.Split(encoded, "$")
+    if len(parts) != 2 {
+        return false
+    }
+    salt, err := base64.RawStdEncoding.DecodeString(parts[0])
+    if err != nil {
+        return false
+    }
+    hash, err := base64.RawStdEncoding.DecodeString(parts[1])
+    if err != nil {
+        return false
+    }
+    // Combine password with pepper
+    pwd := append([]byte(password+pepper), salt...)
+    computed := argon2.IDKey(pwd, salt, 3, 64*1024, 2, uint32(len(hash)))
+    return subtle.ConstantTimeCompare(hash, computed) == 1
+}
+```
+
+Implementations exist for other languages as well: use `argon2-cffi` in Python, `argon2` in Node.js, or the `argon2` crate in Rust with analogous parameters.
+
+### Authenticated Encryption (AEAD)
+
+Do not use Argon2id for encrypting data; instead, derive encryption keys from passwords using Argon2id or HKDF and use an authenticated cipher such as **XChaCha20‑Poly1305** or **AES‑GCM** to encrypt sensitive payloads. Envelope‑encrypt secrets: generate a data encryption key (DEK), encrypt the DEK with a key encryption key (KEK) stored in Vault, and use the DEK to encrypt data with AEAD.
+
+### Credential Hygiene and Breach Monitoring
+
+* Enforce strong password policies and check new passwords against **haveibeenpwned** or similar breach databases.
+* Apply rate limiting at the application and firewall layers to mitigate brute‑force attempts.
+* Rotate secrets regularly using Vault’s dynamic secrets and automated rotation scripts.
+* When implementing user sessions, prefer short‑lived tokens (JWT or PASETO) and store session IDs server side in Redis with idle and absolute timeouts.
+
+These practices ensure that your infrastructure organism’s “immune system” covers not only network and runtime protections but also robust credential handling.

 ## Container Security